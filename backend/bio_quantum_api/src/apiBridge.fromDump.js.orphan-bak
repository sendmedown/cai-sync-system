const dumpPath = "C:\\\\\\\\\\\\\\\\CAI-Sync-System\\\\\\\\\\\\\\\\bio-quantum-trading-platform-clean\\\\\\\\\\\\\\\\claude_dump.txt";
//  ---- CONFIG ----

console.log(`Using path: ${dumpPath}`);

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const { WebSocketServer } = require('ws');
const { v4: uuidv4 } = require('uuid');
const redis = require('redis');
const SecurityWatchdog = require('./SecurityWatchdog');
const FederatedThreatSync = require('./FederatedThreatSync');
const SecurityNetworkWatchdog = require('./SecurityNetworkWatchdog');
const FederatedThreatSyncProtocol = require('./FederatedThreatSyncProtocol');
const KMNuggetValidationEngine = require('./KMNuggetValidationEngine');
const WebSocketEventManager = require('../ws/WebSocketEventManager');
const securityMiddleware = require('../middleware/securityMiddleware');
const CrossSessionValidator = require('../validation/CrossSessionValidator');

const app = express();
const watchdog = new SecurityWatchdog();
const threatSync = new FederatedThreatSync();
const networkWatchdog = new SecurityNetworkWatchdog({
  codonGenerator: require('./CodonGenerator'),
  validationEngine: new KMNuggetValidationEngine(),
  crossSessionValidator: new CrossSessionValidator()
});
const threatSyncProtocol = new FederatedThreatSyncProtocol({
  agentId: 'grok',
  codonGenerator: require('./CodonGenerator'),
  securityWatchdog: watchdog
});
const wsEventManager = new WebSocketEventManager();

app.use(cors());
app.use(express.json());
app.use(securityMiddleware.authenticateJWT);
app.use(securityMiddleware.rateLimit);
app.use((req, res, next) => watchdog.monitorRequest(req, res, next));
app.use((req, res, next) => networkWatchdog.trackRequest(req, res, next));

const fs = require('fs');
const path = require('path');
const logFile = path.join(__dirname, 'apiBridge.log');

function log(message, level = 'INFO') {
  const timestamp = new Date().toISOString();
  fs.appendFileSync(logFile, `[${timestamp}] ${level}: ${message}\n`);
}

log('Starting API Bridge server...');

const dnaStrands = new Map();
global.wss = new WebSocketServer({ port: 5003 });

wss.on('connection', (ws, req) => {
  const token = req.url.split('token=')[1];
  try {
    jwt.verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
    ws.sessionId = uuidv4();
    log(`WebSocket connected, sessionId: ${ws.sessionId}`);
  } catch (err) {
    ws.close();
    log(`WebSocket connection failed: ${err.message}`, 'ERROR');
  }
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ready' });
});

app.post('/nugget/create', (req, res) => {
  const { userId, content, promptId, context } = req.body;
  const token = req.headers.authorization?.split(' ')[1];
  try {
    jwt.verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
    if (!userId || !content || !promptId || !context?.sessionId) {
      throw new Error('Missing required fields');
    }
    const nuggetId = uuidv4();
    const sessionId = context.sessionId;
    const codon = {
      nuggetId,
      content,
      promptId,
      type: 'Condition',
      origin: 'User',
      timestamp: new Date().toISOString()
    };
    const strand = dnaStrands.get(sessionId) || { sessionId, codons: [] };
    strand.codons.push(codon);
    dnaStrands.set(sessionId, strand);
    
    wss.clients.forEach(client => {
      if (client.sessionId === sessionId) {
        client.send(JSON.stringify({ type: 'nugget_update', ...codon, requestId: uuidv4() }));
      }
    });
    
    wsEventManager.emit('security_event', { type: 'nugget_created', nuggetId, sessionId });
    res.status(200).json({ status: 'success', nuggetId, sessionId, requestId: uuidv4() });
    log(`Nugget created: ${nuggetId}, session: ${sessionId}`);
  } catch (err) {
    res.status(401).json({ error: err.message || 'Invalid JWT', requestId: uuidv4() });
    log(`Nugget create failed: ${err.message}`, 'ERROR');
  }
});

app.post('/security/event', (req, res) => {
  const { event } = req.body;
  wsEventManager.emit('security_event', event);
  res.status(200).json({ status: 'broadcasted' });
});

app.post('/security/incident', (req, res) => {
  const { incident } = req.body;
  wsEventManager.emit('security_incident', incident);
  res.status(200).json({ status: 'broadcasted' });
});

app.post('/sync/threat', (req, res) => {
  const { signature } = req.body;
  try {
    if (!signature.vectorHash || !signature.timestamp || !signature.sessionSource || !signature.riskLevel) {
      throw new Error('Invalid threat signature format');
    }
    threatSync.handleMessage(null, JSON.stringify({ type: 'threat_signature', signature }));
    wsEventManager.emit('threat_signature', signature);
    res.status(200).json({ status: 'received', syncedAt: new Date().toISOString() });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.get('/sync/threat/pull', (req, res) => {
  const { after } = req.query;
  const fingerprints = threatSync.threatLedger.filter(f => !after || f.syncedAt > after);
  res.status(200).json({ fingerprints });
});

app.post('/validate', (req, res) => {
  const { nugget, comparisonSet } = req.body;
  try {
    const validator = new KMNuggetValidationEngine();
    const result = validator.validate(nugget, comparisonSet || []);
    res.status(200).json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.post('/batch-validate', (req, res) => {
  const { nuggets, comparisonSet } = req.body;
  try {
    const validator = new KMNuggetValidationEngine();
    const results = nuggets.map(nugget => validator.validate(nugget, comparisonSet || []));
    res.status(200).json(results);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.post('/report/compliance', (req, res) => {
  const complianceData = {
    spiCompliance: true,
    validatedNuggets: [],
    timestamp: new Date().toISOString()
  };
  res.status(200).json(complianceData);
});

app.get('/security/alerts', (req, res) => {
  const alerts = [
    { id: '1', type: 'jwt_failure', severity: 'medium', timestamp: new Date().toISOString() },
    { id: '2', type: 'rate_limit', severity: 'low', timestamp: new Date().toISOString() },
    { id: '3', type: 'codon_mutation', severity: 'high', timestamp: new Date().toISOString() }
  ];
  res.status(200).json({ alerts });
});

app.get('/mutation/timeline', (req, res) => {
  const mutationReplayEvents = [
    { id: '1', type: 'codon_created', timestamp: new Date().toISOString(), sequence: 'ATCG' },
    { id: '2', type: 'mutation_detected', timestamp: new Date().toISOString(), sequence: 'ATCC' },
    { id: '3', type: 'repair_initiated', timestamp: new Date().toISOString(), sequence: 'ATCG' }
  ];
  res.status(200).json({ mutationReplayEvents });
});

app.get('/metrics', (req, res) => {
  const metrics = {
    jwtFailures: Math.floor(Math.random() * 10),
    replayAttacks: Math.floor(Math.random() * 5),
    codonMutationRate: Math.random() * 100,
    memoryCorrectionSuccess: 85 + Math.random() * 15,
    activeNuggetThreads: Math.floor(Math.random() * 20),
    topCodonDrift: 'ATCG->ATCC',
    memoryRepairs: Math.floor(Math.random() * 50)
  };
  res.status(200).json(metrics);
});

const metricsWss = new WebSocketServer({ port: 5004 });
metricsWss.on('connection', (ws, req) => {
  const token = req.url.split('token=')[1];
  try {
    jwt.verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
    
    const interval = setInterval(() => {
      const metrics = {
        type: 'metrics_update',
        jwtFailures: Math.floor(Math.random() * 10),
        replayAttacks: Math.floor(Math.random() * 5),
        codonMutationRate: Math.random() * 100,
        memoryCorrectionSuccess: 85 + Math.random() * 15,
        activeNuggetThreads: Math.floor(Math.random() * 20),
        topCodonDrift: 'ATCG->ATCC',
        memoryRepairs: Math.floor(Math.random() * 50),
        timestamp: Date.now()
      };
      ws.send(JSON.stringify(metrics));
    }, 5000);
    
    ws.on('close', () => clearInterval(interval));
  } catch (err) {
    ws.close();
  }
});

app.listen(10000, () => {
  console.log('üöÄ API Bridge server listening on port 10000');
  log('API Bridge server started on port 10000');
});

const { EventEmitter } = require('events');
const WebSocket = require('ws');
    
    this.config = {
      scanInterval: options.scanInterval || 5000,
      maxConcurrentScans: options.maxConcurrentScans || 10,
      threatThreshold: options.threatThreshold || 0.7,
      sessionTimeoutMs: options.sessionTimeoutMs || 30 * 60 * 1000,
      maxRequestsPerMinute: options.maxRequestsPerMinute || 100,
      jwtSecretKey: options.jwtSecretKey || process.env.JWT_SECRET,
      ...options
    };

    this.activeScans = new Set();
    this.endpointHealth = new Map();
    this.sessionTracker = new Map();
    this.requestCounters = new Map();
    this.threatSignatures = new Map();
    this.webSocketConnections = new Map();
    
    this.codonGenerator = options.codonGenerator;
    this.dnaMemorySimulator = options.dnaMemorySimulator;
    this.validationEngine = options.validationEngine;
    this.crossSessionValidator = options.crossSessionValidator;
    
    this.initializeWatchdog();
  }

  async initializeWatchdog() {
    console.log('üï∏Ô∏è Initializing Security Network Watchdog...');
    
    this.startEndpointMonitoring();
    this.startSessionMonitoring();
    this.startWebSocketMonitoring();
    this.startThreatAnalysis();
    this.registerMiddlewareHooks();
    
    console.log('üõ°Ô∏è Security Watchdog fully operational');
    this.emit('watchdog_ready', { timestamp: Date.now() });
  }

  startEndpointMonitoring() {
    const criticalEndpoints = [
      '/nugget/create',
      '/nugget/validate',
      '/auth/login',
      '/auth/refresh',
      '/strategy/build',
      '/memory/trace',
      '/codon/generate'
    ];

    setInterval(async () => {
      for (const endpoint of criticalEndpoints) {
        if (this.activeScans.size < this.config.maxConcurrentScans) {
          this.scanEndpoint(endpoint);
        }
      }
    }, this.config.scanInterval);
  }

  async scanEndpoint(endpoint) {
    const scanId = `scan_${endpoint}_${Date.now()}`;
    this.activeScans.add(scanId);

    try {
      const healthCheck = await this.performEndpointHealthCheck(endpoint);
      const securityScan = await this.performSecurityScan(endpoint);
      
      const result = {
        endpoint,
        scanId,
        timestamp: Date.now(),
        health: healthCheck,
        security: securityScan,
        threats: this.detectEndpointThreats(endpoint, healthCheck, securityScan)
      };

      this.endpointHealth.set(endpoint, result);
      
      if (result.threats.length > 0) {
        this.handleThreatDetection(endpoint, result.threats);
      }
      
      this.emit('endpoint_scanned', result);
    } catch (error) {
      console.error(`‚ùå Endpoint scan failed for ${endpoint}:`, error);
      this.emit('scan_error', { endpoint, error: error.message });
    } finally {
      this.activeScans.delete(scanId);
    }
  }

  async performEndpointHealthCheck(endpoint) {
    return {
      responseTime: Math.random() * 100 + 50,
      statusCode: 200,
      uptime: true,
      lastError: null,
      requestCount: this.getEndpointRequestCount(endpoint),
      timestamp: Date.now()
    };
  }

  async performSecurityScan(endpoint) {
    const scan = {
      jwtValidation: this.checkJWTSecurity(endpoint),
      rateLimiting: this.checkRateLimiting(endpoint),
      sessionIntegrity: this.checkSessionIntegrity(endpoint),
      inputValidation: this.checkInputValidation(endpoint),
      corsConfiguration: this.checkCORSConfiguration(endpoint),
      timestamp: Date.now()
    };
    
    return scan;
  }

  detectEndpointThreats(endpoint, healthCheck, securityScan) {
    const threats = [];

    if (healthCheck.requestCount > this.config.maxRequestsPerMinute) {
      threats.push({
        type: 'rate_limit_exceeded',
        severity: 'high',
        endpoint,
        details: `Request rate: ${healthCheck.requestCount}/min`,
        timestamp: Date.now()
      });
    }

    if (!securityScan.jwtValidation.valid) {
      threats.push({
        type: 'jwt_anomaly',
        severity: 'critical',
        endpoint,
        details: securityScan.jwtValidation.error,
        timestamp: Date.now()
      });
    }

    if (!securityScan.sessionIntegrity.valid) {
      threats.push({
        type: 'session_tampering',
        severity: 'high',
        endpoint,
        details: securityScan.sessionIntegrity.issue,
        timestamp: Date.now()
      });
    }

    return threats;
  }

  startSessionMonitoring() {
    setInterval(() => {
      this.sessionTracker.forEach((session, sessionId) => {
        const age = Date.now() - session.created;
        if (age > this.config.sessionTimeoutMs) {
          this.flagExpiredSession(sessionId, session);
        }
        
        if (this.detectSuspiciousActivity(session)) {
          this.flagSuspiciousSession(sessionId, session);
        }
      });
    }, this.config.scanInterval);
  }

  startWebSocketMonitoring() {
    setInterval(() => {
      this.webSocketConnections.forEach((connection, connectionId) => {
        if (this.detectWebSocketAnomalies(connection)) {
          this.handleWebSocketThreat(connectionId, connection);
        }
      });
    }, this.config.scanInterval / 2);
  }

  startThreatAnalysis() {
    setInterval(async () => {
      const patterns = this.analyzeThreatPatterns();
      
      if (patterns.newThreats.length > 0) {
        await this.updateThreatSignatures(patterns.newThreats);
        this.emit('new_threats_detected', patterns);
      }

      if (this.dnaMemorySimulator) {
        for (const threat of patterns.newThreats) {
          await this.dnaMemorySimulator.storeThreatFingerprint(threat, {
            severity: threat.severity,
            confidence: threat.confidence || 0.8,
            metadata: {
              source: 'security_watchdog',
              detection_method: 'pattern_analysis'
            }
          });
        }
      }
    }, this.config.scanInterval * 2);
  }

  registerMiddlewareHooks() {
    const middlewareHooks = {
      onRequestReceived: this.trackRequest.bind(this),
      onAuthAttempt: this.trackAuthAttempt.bind(this),
      onJWTValidation: this.trackJWTValidation.bind(this),
      onSessionCreate: this.trackSessionCreate.bind(this),
      onWebSocketConnect: this.trackWebSocketConnect.bind(this)
    };
    
    this.middlewareHooks = middlewareHooks;
    console.log('üîó Middleware hooks registered');
  }

  trackRequest(req, res, next) {
    const endpoint = req.path;
    const clientIP = req.ip || req.connection.remoteAddress;
    const timestamp = Date.now();
    
    const key = `${endpoint}_${clientIP}`;
    const counter = this.requestCounters.get(key) || { count: 0, firstRequest: timestamp };
    counter.count++;
    counter.lastRequest = timestamp;
    this.requestCounters.set(key, counter);

    const timeWindow = 60000;
    if (timestamp - counter.firstRequest < timeWindow && counter.count > this.config.maxRequestsPerMinute) {
      this.flagRateLimitViolation(endpoint, clientIP, counter);
    }

    if (next) next();
  }

  trackAuthAttempt(attempt) {
    const session = this.getOrCreateSession(attempt.sessionId);
    session.authAttempts = session.authAttempts || [];
    session.authAttempts.push({
      timestamp: Date.now(),
      success: attempt.success,
      method: attempt.method,
      clientIP: attempt.clientIP
    });

    const recentFailures = session.authAttempts
      .filter(a => !a.success && Date.now() - a.timestamp < 300000)
      .length;

    if (recentFailures > 5) {
      this.flagBruteForceAttempt(attempt.sessionId, session);
    }
  }

  trackJWTValidation(validation) {
    if (!validation.valid) {
      const threat = {
        type: 'invalid_jwt',
        severity: 'high',
        details: validation.error,
        timestamp: Date.now(),
        sessionId: validation.sessionId
      };
      this.handleThreatDetection('jwt_validation', [threat]);
    }
  }

  trackSessionCreate(session) {
    this.sessionTracker.set(session.id, {
      ...session,
      created: Date.now(),
      lastActivity: Date.now(),
      requests: [],
      threats: []
    });
  }

  trackWebSocketConnect(connection) {
    this.webSocketConnections.set(connection.id, {
      ...connection,
      connected: Date.now(),
      messageCount: 0,
      threats: []
    });
  }

  async handleThreatDetection(source, threats) {
    for (const threat of threats) {
      console.warn(`üö® Threat detected from ${source}:`, threat);
      this.threatSignatures.set(`${threat.type}_${Date.now()}`, threat);
      this.emit('threat_detected', { source, threat });
      
      if (threat.severity === 'critical' || threat.severity === 'high') {
        await this.executeAutomatedResponse(threat);
      }
    }
  }

  async executeAutomatedResponse(threat) {
    switch (threat.type) {
      case 'rate_limit_exceeded':
        await this.enforceRateLimit(threat.endpoint);
        break;
      case 'jwt_anomaly':
        await this.invalidateSession(threat.sessionId);
        break;
      case 'session_tampering':
        await this.quarantineSession(threat.sessionId);
        break;
      case 'brute_force':
        await this.blockIP(threat.clientIP);
        break;
      default:
        console.log(`ü§ñ No automated response for threat type: ${threat.type}`);
    }
  }

  checkJWTSecurity(endpoint) {
    return {
      valid: Math.random() > 0.05,
      algorithm: 'HS256',
      expiry: Date.now() + 3600000,
      error: Math.random() > 0.95 ? 'Invalid signature' : null
    };
  }

  checkRateLimiting(endpoint) {
    const requestCount = this.getEndpointRequestCount(endpoint);
    return {
      enabled: true,
      currentRate: requestCount,
      limit: this.config.maxRequestsPerMinute,
      exceeded: requestCount > this.config.maxRequestsPerMinute
    };
  }

  checkSessionIntegrity(endpoint) {
    return {
      valid: Math.random() > 0.02,
      issue: Math.random() > 0.98 ? 'Session token mismatch' : null
    };
  }

  checkInputValidation(endpoint) {
    return {
      sanitized: true,
      validated: true,
      issues: []
    };
  }

  checkCORSConfiguration(endpoint) {
    return {
      configured: true,
      allowedOrigins: ['https://avfqbbfd.manus.space'],
      secure: true
    };
  }

  getEndpointRequestCount(endpoint) {
    let count = 0;
    this.requestCounters.forEach((counter, key) => {
      if (key.startsWith(endpoint)) {
        count += counter.count;
      }
    });
    return count;
  }

  getOrCreateSession(sessionId) {
    if (!this.sessionTracker.has(sessionId)) {
      this.trackSessionCreate({ id: sessionId });
    }
    return this.sessionTracker.get(sessionId);
  }

  detectSuspiciousActivity(session) {
    const now = Date.now();
    const timeSinceCreated = now - session.created;
    const requestRate = session.requests?.length / (timeSinceCreated / 60000) || 0;
    return requestRate > this.config.maxRequestsPerMinute * 2;
  }

  detectWebSocketAnomalies(connection) {
    const messageRate = connection.messageCount / ((Date.now() - connection.connected) / 1000);
    return messageRate > 100;
  }

  analyzeThreatPatterns() {
    const patterns = {
      newThreats: [],
      trendingAttacks: [],
      timestamp: Date.now()
    };

    const recentThreats = Array.from(this.threatSignatures.values())
      .filter(t => Date.now() - t.timestamp < 300000);

    const threatsByType = {};
    recentThreats.forEach(threat => {
      if (!threatsByType[threat.type]) {
        threatsByType[threat.type] = [];
      }
      threatsByType[threat.type].push(threat);
    });

    Object.entries(threatsByType).forEach(([type, threats]) => {
      if (threats.length > 3) {
        patterns.newThreats.push({
          type: `pattern_${type}`,
          severity: 'medium',
          confidence: 0.8,
          occurrences: threats.length,
          timespan: '5_minutes',
          firstSeen: Math.min(...threats.map(t => t.timestamp)),
          lastSeen: Math.max(...threats.map(t => t.timestamp))
        });
      }
    });

    return patterns;
  }

  async enforceRateLimit(endpoint) {
    console.log(`üö¶ Enforcing rate limit on ${endpoint}`);
  }

  async invalidateSession(sessionId) {
    console.log(`üö´ Invalidating session ${sessionId}`);
    this.sessionTracker.delete(sessionId);
  }

  async quarantineSession(sessionId) {
    console.log(`üîí Quarantining session ${sessionId}`);
    const session = this.sessionTracker.get(sessionId);
    if (session) {
      session.quarantined = true;
      session.quarantineReason = 'session_tampering';
    }
  }

  async blockIP(clientIP) {
    console.log(`üõ°Ô∏è Blocking IP ${clientIP}`);
  }

  async updateThreatSignatures(threats) {
    console.log(`üìä Updating threat signatures with ${threats.length} new patterns`);
  }

  getWatchdogStatus() {
    return {
      activeScans: this.activeScans.size,
      endpointsMonitored: this.endpointHealth.size,
      activeSessions: this.sessionTracker.size,
      webSocketConnections: this.webSocketConnections.size,
      threatSignatures: this.threatSignatures.size,
      uptime: Date.now(),
      config: this.config,
      lastUpdate: Date.now()
    };
  }

  shutdown() {
    console.log('üõë Shutting down Security Watchdog...');
    this.emit('watchdog_shutdown', { timestamp: Date.now() });
  }
}
const { EventEmitter } = require('events');
const WebSocket = require('ws');
const crypto = require('crypto');
    
    this.config = {
      agentId: options.agentId || 'claude',
      syncInterval: options.syncInterval || 30000,
      maxFingerprintAge: options.maxFingerprintAge || 3600000,
      trustThreshold: options.trustThreshold || 0.6,
      encryptionKey: options.encryptionKey || process.env.FEDERATION_KEY,
      syncEndpoints: options.syncEndpoints || {
        claude: 'ws://claude-sync.bio-quantum.ai',
        grok: 'ws://grok-sync.bio-quantum.ai',
        chatgpt: 'ws://chatgpt-sync.bio-quantum.ai'
      },
      ...options
    };

    this.connectedAgents = new Map();
    this.sharedFingerprints = new Map();
    this.pendingSyncs = new Set();
    this.trustScores = new Map();
    this.syncHistory = [];
    
    this.dnaMemorySimulator = options.dnaMemorySimulator;
    this.securityWatchdog = options.securityWatchdog;
    this.codonGenerator = options.codonGenerator;
    
    this.isInitialized = false;
    this.lastSyncTimestamp = 0;
    
    this.initializeFederation();
  }

  async initializeFederation() {
    console.log(`üì° Initializing Federated Threat Sync for agent: ${this.config.agentId}`);
    
    try {
      await this.connectToFederatedAgents();
      this.startPeriodicSync();
      this.startThreatBroadcasting();
      this.startTrustManagement();
      
      this.isInitialized = true;
      console.log('üåê Federated Threat Sync Protocol operational');
      this.emit('federation_ready', { agentId: this.config.agentId, timestamp: Date.now() });
    } catch (error) {
      console.error('‚ùå Federation initialization failed:', error);
      this.emit('federation_error', { error: error.message, timestamp: Date.now() });
    }
  }

  async connectToFederatedAgents() {
    const connectionPromises = [];
    
    Object.entries(this.config.syncEndpoints).forEach(([agentName, endpoint]) => {
      if (agentName !== this.config.agentId) {
        connectionPromises.push(this.connectToAgent(agentName, endpoint));
      }
    });
    
    await Promise.allSettled(connectionPromises);
    console.log(`üîó Connected to ${this.connectedAgents.size} federated agents`);
  }

  async connectToAgent(agentName, endpoint) {
    try {
      const ws = new WebSocket(endpoint, {
        headers: {
          'Agent-ID': this.config.agentId,
          'Protocol-Version': '1.0',
          'Authentication': this.generateAuthToken(agentName)
        }
      });

      ws.on('open', () => {
        console.log(`‚úÖ Connected to ${agentName}`);
        this.connectedAgents.set(agentName, {
          connection: ws,
          status: 'connected',
          lastPing: Date.now(),
          syncCount: 0
        });
        this.initializeTrustScore(agentName);
        this.sendHandshake(agentName);
      });

      ws.on('message', (data) => {
        this.handleIncomingMessage(agentName, data);
      });

      ws.on('close', () => {
        console.log(`‚ùå Disconnected from ${agentName}`);
        this.handleAgentDisconnection(agentName);
      });

      ws.on('error', (error) => {
        console.error(`‚ö†Ô∏è Connection error with ${agentName}:`, error);
      });

    } catch (error) {
      console.error(`Failed to connect to ${agentName}:`, error);
    }
  }

  startPeriodicSync() {
    setInterval(async () => {
      if (this.connectedAgents.size > 0) {
        await this.performFederatedSync();
      }
    }, this.config.syncInterval);
  }

  startThreatBroadcasting() {
    if (this.securityWatchdog) {
      this.securityWatchdog.on('threat_detected', async (event) => {
        await this.broadcastThreatFingerprint(event.threat);
      });
    }

    if (this.dnaMemorySimulator) {
      this.dnaMemorySimulator.on('threat_stored', async (fingerprint) => {
        await this.broadcastThreatFingerprint(fingerprint);
      });
    }
  }

  startTrustManagement() {
    setInterval(() => {
      this.updateTrustScores();
      this.cleanupExpiredFingerprints();
    }, this.config.syncInterval * 2);
  }

  async performFederatedSync() {
    const syncId = `sync_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
    this.pendingSyncs.add(syncId);
    
    try {
      const localFingerprints = await this.collectLocalFingerprints();
      const syncPackage = this.createSyncPackage(syncId, localFingerprints);
      
      await this.broadcastSyncPackage(syncPackage);
      this.lastSyncTimestamp = Date.now();
      
      this.emit('sync_completed', { syncId, fingerprints: localFingerprints.length });
    } catch (error) {
      console.error(`‚ùå Sync failed for ${syncId}:`, error);
      this.emit('sync_error', { syncId, error: error.message });
    } finally {
      this.pendingSyncs.delete(syncId);
    }
  }

  async collectLocalFingerprints() {
    const fingerprints = [];
    
    if (this.dnaMemorySimulator) {
      const recentThreats = Array.from(this.dnaMemorySimulator.threatFingerprints.values())
        .filter(fp => Date.now() - fp.timestamp < this.config.maxFingerprintAge);
      fingerprints.push(...recentThreats.map(fp => this.convertToCodonFingerprint(fp)));
    }

    if (this.securityWatchdog) {
      const watchdogThreats = Array.from(this.securityWatchdog.threatSignatures.values())
        .filter(threat => Date.now() - threat.timestamp < this.config.maxFingerprintAge);
      fingerprints.push(...watchdogThreats.map(threat => this.convertThreatToCodonFingerprint(threat)));
    }
    
    return fingerprints;
  }

  convertToCodonFingerprint(threat) {
    return {
      id: threat.id || this.generateFingerprintId(threat),
      format_version: "1.0",
      agent_source: this.config.agentId,
      timestamp: threat.timestamp,
      codon_signature: {
        pattern: this.generateCodonPattern(threat),
        classification: threat.type || 'unknown',
        severity: threat.severity || 'medium',
        confidence: threat.confidence || 0.7
      },
      vector_data: {
        type: threat.vector?.type || 'generic',
        endpoints: threat.endpoints || [],
        ips: threat.ips || [],
        signatures: threat.signatures || []
      },
      metadata: {
        detection_method: threat.metadata?.detection_method || 'automatic',
        false_positive_rate: threat.metadata?.false_positive_rate || 0.1,
        correlation_id: threat.metadata?.correlation_id
      }
    };
  }

  convertThreatToCodonFingerprint(threat) {
    return {
      id: `watchdog_${threat.type}_${threat.timestamp}`,
      format_version: "1.0",
      agent_source: this.config.agentId,
      timestamp: threat.timestamp,
      codon_signature: {
        pattern: this.generateThreatCodonPattern(threat),
        classification: threat.type,
        severity: threat.severity,
        confidence: 0.8
      },
      vector_data: {
        type: threat.type,
        endpoint: threat.endpoint,
        details: threat.details,
        session_id: threat.sessionId
      },
      metadata: {
        detection_method: 'security_watchdog',
        source: 'bio_quantum_platform'
      }
    };
  }

  generateCodonPattern(threat) {
    const data = JSON.stringify(threat);
    const hash = crypto.createHash('sha256').update(data).digest('hex');
    const codonPattern = [];
    
    for (let i = 0; i < hash.length; i += 8) {
      const segment = hash.substr(i, 8);
      codonPattern.push({
        position: i / 8,
        codon: segment,
        weight: parseInt(segment.substr(0, 2), 16) / 255
      });
    }
    
    return codonPattern;
  }

  generateThreatCodonPattern(threat) {
    const components = [
      threat.type,
      threat.severity,
      threat.timestamp
    ];
    
    const hash = crypto.createHash('sha256').update(components.join('')).digest('hex');
    const codonPattern = [];
    
    for (let i = 0; i < hash.length; i += 8) {
      const segment = hash.substr(i, 8);
      codonPattern.push({
        position: i / 8,
        codon: segment,
        weight: parseInt(segment.substr(0, 2), 16) / 255
      });
    }
    
    return codonPattern;
  }

  generateFingerprintId(threat) {
    return `fingerprint_${crypto.createHash('sha256').update(JSON.stringify(threat)).digest('hex').slice(0, 16)}`;
  }

  generateAuthToken(agentName) {
    const payload = {
      agentId: this.config.agentId,
      timestamp: Date.now(),
      targetAgent: agentName
    };
    
    return crypto.createHmac('sha256', this.config.encryptionKey || 'default_key')
      .update(JSON.stringify(payload)).digest('hex');
  }

  async broadcastThreatFingerprint(fingerprint) {
    const syncPackage = {
      type: 'threat_signature',
      signature: fingerprint,
      source: this.config.agentId,
      timestamp: Date.now()
    };

    this.connectedAgents.forEach((agent, agentName) => {
      if (agent.status === 'connected') {
        agent.connection.send(JSON.stringify(syncPackage));
        console.log(`üì° Sent threat fingerprint to ${agentName}`);
      }
    });
  }

  async broadcastSyncPackage(syncPackage) {
    this.connectedAgents.forEach((agent, agentName) => {
      if (agent.status === 'connected') {
        agent.connection.send(JSON.stringify(syncPackage));
        agent.syncCount++;
        console.log(`üì§ Sent sync package to ${agentName}, count: ${agent.syncCount}`);
      }
    });
  }

  createSyncPackage(syncId, fingerprints) {
    return {
      type: 'federated_sync',
      syncId,
      fingerprints,
      source: this.config.agentId,
      timestamp: Date.now()
    };
  }

  initializeTrustScore(agentName) {
    this.trustScores.set(agentName, {
      score: 0.5,
      lastUpdate: Date.now(),
      successfulSyncs: 0,
      failedSyncs: 0,
      lastValidation: null
    });
  }

  updateTrustScores() {
    this.trustScores.forEach((score, agentName) => {
      const agent = this.connectedAgents.get(agentName);
      if (agent) {
        const timeSinceLastSync = Date.now() - agent.lastPing;
        const syncSuccessRate = agent.syncCount > 0 ? 
          agent.syncCount / (agent.syncCount + score.failedSyncs) : 0;
        
        const newScore = Math.min(1, Math.max(0, 
          score.score + (syncSuccessRate - 0.5) * 0.1 - timeSinceLastSync / 3600000
        ));
        
        score.score = newScore;
        score.lastUpdate = Date.now();
        
        if (newScore < this.config.trustThreshold) {
          console.warn(`‚ö†Ô∏è Trust score for ${agentName} below threshold: ${newScore}`);
        }
      }
    });
  }

  cleanupExpiredFingerprints() {
    const now = Date.now();
    this.sharedFingerprints.forEach((fingerprint, id) => {
      if (now - fingerprint.timestamp > this.config.maxFingerprintAge) {
        this.sharedFingerprints.delete(id);
        console.log(`üóëÔ∏è Removed expired fingerprint: ${id}`);
      }
    });
  }

  async handleIncomingMessage(agentName, data) {
    try {
      const message = JSON.parse(data);
      
      if (message.type === 'threat_signature') {
        const trustScore = this.trustScores.get(agentName)?.score || 0;
        if (trustScore < this.config.trustThreshold) {
          console.warn(`üö´ Dropped low-trust signature from ${agentName}`);
          return;
        }
        
        this.sharedFingerprints.set(message.signature.id, message.signature);
        this.syncHistory.push({
          agentName,
          signatureId: message.signature.id,
          receivedAt: Date.now()
        });
        
        console.log(`üì• Received threat signature from ${agentName}: ${message.signature.id}`);
        this.emit('new_signature', { agentName, signature: message.signature });
        
      } else if (message.type === 'federated_sync') {
        message.fingerprints.forEach(fingerprint => {
          this.sharedFingerprints.set(fingerprint.id, fingerprint);
        });
        
        this.syncHistory.push({
          agentName,
          syncId: message.syncId,
          fingerprintCount: message.fingerprints.length,
          receivedAt: Date.now()
        });
        
        console.log(`üì¶ Received sync package from ${agentName}: ${message.syncId}`);
        this.emit('sync_received', { 
          agentName, 
          syncId: message.syncId, 
          fingerprints: message.fingerprints 
        });
      }
    } catch (error) {
      console.error(`‚ùå Error processing message from ${agentName}:`, error);
    }
  }

  handleAgentDisconnection(agentName) {
    const agent = this.connectedAgents.get(agentName);
    if (agent) {
      agent.status = 'disconnected';
      agent.lastPing = Date.now();
      this.connectedAgents.set(agentName, agent);
      
      console.log(`üîå Agent ${agentName} disconnected, trust score: ${this.trustScores.get(agentName)?.score || 0}`);
      this.emit('agent_disconnected', { agentName, timestamp: Date.now() });
    }
  }
}
Protocol;

const cosineSimilarity = require('compute-cosine-similarity');
const natural = require('natural');
const tokenizer = new natural.WordTokenizer();

  computeConfidenceScore(nugget) {
    const sourceWeight = nugget.sourceCredibility || 0.3;
    const freshnessWeight = this._computeFreshnessWeight(nugget.timestamp);
    const historicalWeight = nugget.historicalAccuracy || 0.4;
    const volatilityWeight = nugget.volatilityCorrelation || 0.3;
    
    const weightedScore = (
      0.25 * sourceWeight +
      0.25 * freshnessWeight +
      0.25 * historicalWeight +
      0.25 * volatilityWeight
    );
    
    return Math.min(1.0, Math.max(0.0, weightedScore));
  }

  _computeFreshnessWeight(timestamp) {
    const hoursSince = (Date.now() - new Date(timestamp)) / 36e5;
    if (hoursSince < 1) return 1.0;
    if (hoursSince < 24) return 0.8;
    if (hoursSince < 168) return 0.6;
    return 0.3;
  }

  detectAnomaly(nugget, comparisonSet = []) {
    if (!comparisonSet.length) return false;
    
    const distances = comparisonSet.map(other => {
      const a = tokenizer.tokenize(nugget.text).map(t => t.toLowerCase());
      const b = tokenizer.tokenize(other.text).map(t => t.toLowerCase());
      return 1 - cosineSimilarity(a, b);
    });
    
    const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
    return avgDistance > this.anomalyThreshold;
  }

  validate(nugget, comparisonSet = []) {
    const confidence = this.computeConfidenceScore(nugget);
    const anomaly = this.detectAnomaly(nugget, comparisonSet);
    
    return {
      nuggetId: nugget.nuggetId,
      confidence,
      anomaly,
      valid: confidence >= this.confidenceThreshold && !anomaly
    };
  }
}
const crypto = require('crypto');
const { v4: uuidv4 } = require('uuid');

class CodonGenerator {
  constructor(options = {}) {
    this.seed = options.seed || crypto.randomBytes(16).toString('hex');
    this.codonLength = options.codonLength || 4;
    this.alphabet = options.alphabet || ['A', 'C', 'G', 'T'];
    this.initialize();
  }

  initialize() {
    console.log('üß¨ CodonGenerator initialized with seed:', this.seed);
  }

  generateCodon() {
    let codon = '';
    for (let i = 0; i < this.codonLength; i++) {
      const randomIndex = crypto.createHash('sha256').update(this.seed + i).digest('hex') % this.alphabet.length;
      codon += this.alphabet[randomIndex];
    }
    return codon;
  }

  generateSequence(length = 10) {
    const sequence = [];
    for (let i = 0; i < length; i++) {
      sequence.push(this.generateCodon());
    }
    return sequence;
  }

  generateDegSequence(degData = {}, length = 10) {
    const seed = degData.seed || this.seed;
    const sequence = this.generateSequence(length);
    return {
      id: uuidv4(),
      sequence,
      degScore: degData.score || Math.random(),
      timestamp: new Date().toISOString()
    };
  }

  integrateWithValidator(validator, sequence) {
    if (validator) {
      return validator.validate(sequence);
    }
    return { valid: true, sequence };
  }
}

module.exports = CodonGenerator;

const { v4: uuidv4 } = require('uuid');

class PromptChainRouter {
  constructor(options = {}) {
    this.routes = options.routes || {};
    this.defaultRoute = options.defaultRoute || ((prompt) => ({ response: 'Default response', id: uuidv4() }));
    this.initialize();
  }

  initialize() {
    console.log('üîó PromptChainRouter initialized with routes:', Object.keys(this.routes));
  }

  addRoute(key, handler) {
    this.routes[key] = handler;
  }

  routePrompt(prompt) {
    const key = this.getRouteKey(prompt);
    const handler = this.routes[key] || this.defaultRoute;
    return handler(prompt);
  }

  getRouteKey(prompt) {
    if (prompt.includes('trading')) return 'trading';
    if (prompt.includes('deg')) return 'deg';
    return 'default';
  }

  integrateWithBridge(prompt, response) {
    if (global.wss) {
      global.wss.clients.forEach(client => {
        client.send(JSON.stringify({ type: 'prompt_response', prompt, response, id: uuidv4() }));
      });
    }
    return response;
  }

  integrateWithValidator(validator, response) {
    if (validator) {
      return validator.validate(response);
    }
    return response;
  }
}

module.exports = PromptChainRouter;

const jwt = require('jsonwebtoken');
const { WebSocketServer } = require('ws');
const fs = require('fs').promises;
const path = require('path');
const { v4: uuidv4 } = require('uuid');

  initialize() {
    console.log('üîê Security Watchdog initialized');
    this.wss.on('connection', (ws) => {
      ws.send(JSON.stringify({ type: 'init', alerts: this.threatAlerts }));
    });
  }

  async monitorRequest(req, res, next) {
    const token = req.headers.authorization?.split(' ')[1];
    const ip = req.ip;
    const sessionId = req.query.sessionId || 'unknown';
    const alert = {
      id: uuidv4(),
      timestamp: new Date().toISOString(),
      ip,
      sessionId,
      threatLevel: 'low'
    };

    if (!token) {
      alert.threatLevel = 'critical';
      alert.eventType = 'missing_jwt';
      this.logThreat(alert);
      return res.status(401).json({ error: 'Missing JWT' });
    }

    try {
      jwt.verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
      
      const count = (this.requestCounts.get(ip) || 0) + 1;
      this.requestCounts.set(ip, count);
      
      if (count > 100) {
        alert.threatLevel = 'critical';
        alert.eventType = 'session_spamming';
        this.logThreat(alert);
        return res.status(429).json({ error: 'Rate limit exceeded' });
      }
      
      next();
    } catch (err) {
      alert.threatLevel = 'critical';
      alert.eventType = 'invalid_jwt';
      this.logThreat(alert);
      return res.status(401).json({ error: 'Invalid JWT' });
    }
  }

  async logThreat(alert) {
    this.threatAlerts.push(alert);
    await fs.writeFile(this.alertFile, JSON.stringify(this.threatAlerts, null, 2));
    
    this.wss.clients.forEach(client => {
      if (client.readyState === WebSocketServer.OPEN) {
        client.send(JSON.stringify({ type: 'security_alert', alert }));
      }
    });
    
    console.log(`üö® Threat detected: ${alert.eventType}, Level: ${alert.threatLevel}`);
  }
}
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class BioQuantumEvidenceCollector {
  constructor(options = {}) {
    this.collectorId = 'bioq_evidence_collector_v2';
    this.config = {
      maxRingBufferSize: options.maxRingBufferSize || 1000,
      evidenceRetentionHours: options.evidenceRetention || 72,
      fileSystemStorage: options.enableFileStorage || true,
      redisStorage: options.enableRedisStorage || false,
      evidenceDirectory: options.evidenceDir || './evidence'
    };
    
    this.evidenceRingBuffer = [];
    this.evidenceIndex = new Map();
    this.incidentEvidence = new Map();
    this.collectionStats = {
      totalEvidence: 0,
      evidenceByType: {}
    };
    
    this.initializeEvidenceCollection();
  }

  async initializeEvidenceCollection() {
    try {
      if (this.config.fileSystemStorage) {
        await fs.mkdir(this.config.evidenceDirectory, { recursive: true });
      }
      console.log('üìÅ Bio-Quantum Evidence Collector initialized');
    } catch (error) {
      console.error('‚ùå Evidence collector initialization failed:', error);
    }
  }

  async collectEvidence(securityEvent, incidentId = null) {
    const evidenceId = crypto.randomUUID();
    const timestamp = new Date().toISOString();
    
    const evidence = {
      evidenceId,
      timestamp,
      incidentId,
      securityEvent: {
        ...securityEvent,
        metadata: {
          ...securityEvent.metadata,
          authToken: '[REDACTED]'
        }
      },
      metadata: {
        collectorId: this.collectorId
      }
    };
    
    this.evidenceRingBuffer.push(evidence);
    this.evidenceIndex.set(evidenceId, evidence);
    
    console.log(`üìã Evidence collected: ${evidenceId}`);
    return { evidenceId, collected: true };
  }
}

module.exports = BioQuantumEvidenceCollector;

const jwt = require('jsonwebtoken');
const { RateLimiterMemory } = require('rate-limiter-flexible');

const rateLimiter = new RateLimiterMemory({
  points: 100,
  duration: 60,
});

module.exports = {
  authenticateJWT: (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ error: 'Missing JWT' });
    }
    try {
      jwt.verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
      next();
    } catch (err) {
      res.status(401).json({ error: 'Invalid JWT' });
    }
  },
  
  rateLimit: async (req, res, next) => {
    const ip = req.ip || req.connection.remoteAddress;
    try {
      await rateLimiter.consume(ip);
      next();
    } catch (err) {
      res.status(429).json({ error: 'Rate limit exceeded' });
    }
  }
};

const { EventEmitter } = require('events');
const { WebSocketServer } = require('ws');

  initialize() {
    console.log('üîó WebSocketEventManager initialized');
    
    this.wss.on('connection', (ws, req) => {
      const token = req.url.split('token=')[1];
      try {
        require('jsonwebtoken').verify(token, process.env.JWT_SECRET || 'dummy_jwt_secret_123');
        ws.sessionId = require('uuid').v4();
        console.log(`üîå WebSocket connected, sessionId: ${ws.sessionId}`);
        ws.send(JSON.stringify({ type: 'init', status: 'connected' }));
      } catch (err) {
        ws.close();
        console.error(`‚ùå WebSocket connection failed: ${err.message}`);
      }
    });

    this.on('security_event', (event) => {
      this.broadcast({ type: 'security_event', event });
    });

    this.on('security_incident', (incident) => {
      this.broadcast({ type: 'security_incident', incident });
    });

    this.on('threat_signature', (signature) => {
      this.broadcast({ type: 'threat_signature', signature });
    });
  }

  broadcast(data) {
    this.wss.clients.forEach(client => {
      if (client.readyState === WebSocketServer.OPEN) {
        client.send(JSON.stringify(data));
      }
    });
  }
}
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto');

  initialize() {
    console.log('üîç CrossSessionValidator initialized');
  }

  validateSession(sessionId, requestData) {
    const session = this.sessionStore.get(sessionId);
    if (!session || Date.now() - session.created > this.maxSessionAge) {
      return { valid: false, error: 'Session expired or invalid' };
    }

    const hash = this.generateRequestHash(requestData);
    if (session.requests.includes(hash)) {
      return { valid: false, error: 'Replay attack detected' };
    }

    session.requests.push(hash);
    this.sessionStore.set(sessionId, session);
    return { valid: true };
  }

  generateRequestHash(requestData) {
    return crypto.createHash('sha256').update(JSON.stringify(requestData)).digest('hex');
  }

  addSession(sessionId) {
    this.sessionStore.set(sessionId, {
      id: sessionId,
      created: Date.now(),
      requests: []
    });
  }
}
import React, { useState, useEffect } from 'react';
import ReactFlow, { Controls } from 'reactflow';
import 'reactflow/dist/style.css';
import { v4 as uuidv4 } from 'uuid';

const StrategyMemoryMap = ({ websocketUrl = 'wss://bioquantum-api.onrender.com', authToken }) => {
  const [nuggets, setNuggets] = useState([]);
  const [codonTraces, setCodonTraces] = useState([]);
  const [mutationReplayEvents, setMutationReplayEvents] = useState([]);
  const [replayIndex, setReplayIndex] = useState(0);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [semanticMap, setSemanticMap] = useState({ nodes: [], edges: [] });
  const [nuggetNarratives, setNuggetNarratives] = useState({});

  useEffect(() => {
    if (!authToken) return;
    const ws = new WebSocket(`${websocketUrl}?sessionId=strategy_map_${uuidv4()}&authToken=${authToken}`);
    
    ws.onopen = () => console.log('üß¨ Strategy Memory Map connected');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'nugget_update') {
        setNuggets(prev => [data, ...prev].slice(0, 100));
      } else if (data.type === 'codon_trace') {
        setCodonTraces(prev => [data, ...prev].slice(0, 50));
      } else if (data.type === 'mutation_replay') {
        setMutationReplayEvents(data.events);
      }
    };
    ws.onerror = (error) => console.error('‚ùå WebSocket error:', error);
    return () => ws.close();
  }, [authToken, websocketUrl]);

  useEffect(() => {
    // Fetch semanticZoomMap.json
    fetch('/shared/phase4_mutation_replay_bundle/semanticZoomMap.json')
      .then(res => res.json())
      .then(data => setSemanticMap({
        nodes: data.nodes.map(node => ({
          id: node.id,
          data: { label: node.label, tooltip: nuggetNarratives[node.id] || 'No narrative' },
          position: node.position
        })),
        edges: data.edges
      }))
      .catch(err => {
        console.error('‚ùå Failed to load semanticZoomMap.json:', err);
        // Mock data fallback
        setSemanticMap({
          nodes: [
            { id: 'session_1', data: { label: 'Session 1', tooltip: 'Session root' }, position: { x: 0, y: 0 } },
            { id: 'nugget_1', data: { label: 'Nugget 1', tooltip: 'Market analysis' }, position: { x: 100, y: 100 } },
            { id: 'codon_1', data: { label: 'Codon 1', tooltip: 'Strategy codon' }, position: { x: 200, y: 200 } }
          ],
          edges: [
            { id: 'e1', source: 'session_1', target: 'nugget_1' },
            { id: 'e2', source: 'nugget_1', target: 'codon_1' }
          ]
        });
      });

    // Fetch nuggetNarratives.json
    fetch('/shared/phase4_mutation_replay_bundle/nuggetNarratives.json')
      .then(res => res.json())
      .then(setNuggetNarratives)
      .catch(err => {
        console.error('‚ùå Failed to load nuggetNarratives.json:', err);
        setNuggetNarratives({
          'nugget_1': 'This nugget represents a market analysis strategy with high confidence.',
          'codon_1': 'Codon for automated trading logic, mutation-free.'
        });
      });
  }, []);

  const handleReplaySlider = (e) => {
    setReplayIndex(parseInt(e.target.value));
  };

  const zoomIn = () => setZoomLevel(prev => Math.min(prev + 0.2, 3));
  const zoomOut = () => setZoomLevel(prev => Math.max(prev - 0.2, 0.5));

  const currentReplayEvent = mutationReplayEvents[replayIndex] || {};

  return (
    <div className="p-4">
      <h2 className="text-2xl font-bold mb-4">Strategy Memory Map</h2>
      <div style={{ height: '500px', width: '100%', border: '1px solid
        <ReactFlow
          nodes={semanticMap.nodes}
          edges={semanticMap.edges}
          fitView
          style={{ transform: `scale(${zoomLevel})`, transition: 'transform 0.3s' }}
          nodesDraggable={false}
        >
          <Controls />
        </ReactFlow>
      </div>
      <div className="mt-4">
        <button className="bg-blue-500 text-white px-4 py-2 rounded mr-2" onClick={zoomIn}>Zoom In</button>
        <button className="bg-blue-500 text-white px-4 py-2 rounded" onClick={zoomOut}>Zoom Out</button>
      </div>
      <div className="mt-4">
        <h3 className="text-lg font-semibold">Mutation Replay</h3>
        <input
          type="range"
          min={0}
          max={mutationReplayEvents.length - 1}
          value={replayIndex}
          onChange={handleReplaySlider}
          className="w-full"
        />
        <p>Current Event: {JSON.stringify(currentReplayEvent)}</p>
      </div>
      <div className="mt-4">
        <h3 className="text-lg font-semibold">Recent Nuggets</h3>
        <ul className="list-disc pl-5">
          {nuggets.map(nugget => (
            <li key={nugget.nuggetId} title={nuggetNarratives[nugget.nuggetId] || 'No narrative'}>
              {nugget.content} (ID: {nugget.nuggetId}, Session: {nugget.sessionId})
            </li>
          ))}
        </ul>
      </div>
      <div className="mt-4">
        <h3 className="text-lg font-semibold">Codon Traces</h3>
        <ul className="list-disc pl-5">
          {codonTraces.map(trace => (
            <li key={trace.requestId}>
              {trace.sequence} (Score: {trace.degScore})
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default StrategyMemoryMap;

import React, { useState, useEffect } from 'react';

const SecurityDashboard = ({ websocketUrl = 'wss://bioquantum-api.onrender.com', authToken }) => {
  const [securityEvents, setSecurityEvents] = useState([]);

  useEffect(() => {
    if (!authToken) return;
    const ws = new WebSocket(`${websocketUrl}?sessionId=security_dashboard&authToken=${authToken}`);
    
    ws.onopen = () => console.log('üîí Security Dashboard connected');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'security_event') {
        setSecurityEvents(prev => [data.event, ...prev.slice(0, 99)]);
      }
    };
    return () => ws.close();
  }, [authToken, websocketUrl]);

  return (
    <div className="p-4">
      <h2 className="text-2xl font-bold mb-4">Security Dashboard</h2>
      <div className="bg-gray-100 p-4 rounded">
        <h3 className="text-lg font-semibold mb-2">Recent Security Events</h3>
        <ul className="space-y-2">
          {securityEvents.map((event, index) => (
            <li key={index} className="bg-white p-2 rounded shadow">
              <span className="font-semibold">{event.type}</span>
              <span className="text-gray-600 ml-2">{event.timestamp}</span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default SecurityDashboard;

import React, { useState, useEffect } from 'react';
import { Sparklines, SparklinesLine } from 'react-sparklines';

const AgentStressDashboard = ({ apiUrl = 'https://bioquantum-api.onrender.com', websocketUrl = 'wss://bioquantum-api.onrender.com', authToken }) => {
  const [metrics, setMetrics] = useState({
    jwtFailures: { value: 0, history: [] },
    replayAttacks: { value: 0, history: [] },
    codonMutationRate: { value: 0, history: [] },
    memoryCorrectionSuccess: { value: 0, history: [] },
    topCodonDrift: 'N/A',
    memoryRepairs: 0
  });
  const [isDebugOpen, setIsDebugOpen] = useState(false);

  useEffect(() => {
    // WebSocket for live metrics
    const ws = new WebSocket(`${websocketUrl}/metrics/ws?token=${authToken}`);
    ws.onopen = () => console.log('üõ°Ô∏è Agent Stress Dashboard WebSocket connected');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'metrics_update') {
        setMetrics(prev => ({
          jwtFailures: { value: data.jwtFailures, history: [...prev.jwtFailures.history, data.jwtFailures].slice(-50) },
          replayAttacks: { value: data.replayAttacks, history: [...prev.replayAttacks.history, data.replayAttacks].slice(-50) },
          codonMutationRate: { value: data.codonMutationRate, history: [...prev.codonMutationRate.history, data.codonMutationRate].slice(-50) },
          memoryCorrectionSuccess: { value: data.memoryCorrectionSuccess, history: [...prev.memoryCorrectionSuccess.history, data.memoryCorrectionSuccess].slice(-50) },
          topCodonDrift: data.topCodonDrift || 'N/A',
          memoryRepairs: data.memoryRepairs || 0
        }));
      }
    };
    ws.onerror = (error) => console.error('‚ùå WebSocket error:', error);
    ws.onclose = () => console.log('WebSocket closed');

    // Fallback polling if WebSocket fails
    const interval = setInterval(async () => {
      try {
        const response = await fetch(`${apiUrl}/metrics`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        const data = await response.json();
        setMetrics(prev => ({
          jwtFailures: { value: data.jwtFailures, history: [...prev.jwtFailures.history, data.jwtFailures].slice(-50) },
          replayAttacks: { value: data.replayAttacks, history: [...prev.replayAttacks.history, data.replayAttacks].slice(-50) },
          codonMutationRate: { value: data.codonMutationRate, history: [...prev.codonMutationRate.history, data.codonMutationRate].slice(-50) },
          memoryCorrectionSuccess: { value: data.memoryCorrectionSuccess, history: [...prev.memoryCorrectionSuccess.history, data.memoryCorrectionSuccess].slice(-50) },
          topCodonDrift: data.topCodonDrift || 'N/A',
          memoryRepairs: data.memoryRepairs || 0
        }));
      } catch (error) {
        console.error('‚ùå Metrics fetch error:', error);
      }
    }, 5000);

    return () => {
      ws.close();
      clearInterval(interval);
    };
  }, [apiUrl, websocketUrl, authToken]);

  const getBadgeStyle = (value, threshold) => ({
    color: value > threshold ? '#dc2626' : '#15803d',
    backgroundColor: value > threshold ? '#fee2e2' : '#dcfce7',
    padding: '4px 8px',
    borderRadius: '4px'
  });

  return (
    <div className="p-4 bg-gray-100 rounded-lg">
      <h2 className="text-2xl font-bold mb-4">Agent Stress Dashboard</h2>
      <div className="grid grid-cols-2 gap-4">
        <div>
          <h3 style={getBadgeStyle(metrics.jwtFailures.value, 5)}>
            JWT Failures: {metrics.jwtFailures.value}
            {metrics.jwtFailures.value > 10 && <span className="ml-2 bg-red-600 text-white px-2 py-1 rounded">High</span>}
          </h3>
          <Sparklines data={metrics.jwtFailures.history} width={100} height={20}>
            <SparklinesLine color={metrics.jwtFailures.value > 5 ? 'red' : 'green'} />
          </Sparklines>
        </div>
        <div>
          <h3 style={getBadgeStyle(metrics.replayAttacks.value, 5)}>
            Replay Attacks: {metrics.replayAttacks.value}
            {metrics.replayAttacks.value > 10 && <span className="ml-2 bg-red-600 text-white px-2 py-1 rounded">High</span>}
          </h3>
          <Sparklines data={metrics.replayAttacks.history} width={100} height={20}>
            <SparklinesLine color={metrics.replayAttacks.value > 5 ? 'red' : 'green'} />
          </Sparklines>
        </div>
        <div>
          <h3 style={getBadgeStyle(metrics.codonMutationRate.value, 20)}>
            Codon Mutation Rate: {metrics.codonMutationRate.value.toFixed(2)}%
            {metrics.codonMutationRate.value > 30 && <span className="ml-2 bg-red-600 text-white px-2 py-1 rounded">High</span>}
          </h3>
          <Sparklines data={metrics.codonMutationRate.history} width={100} height={20}>
            <SparklinesLine color={metrics.codonMutationRate.value > 20 ? 'red' : 'green'} />
          </Sparklines>
        </div>
        <div>
          <h3 style={getBadgeStyle(100 - metrics.memoryCorrectionSuccess.value, 10)}>
            Memory Correction Success: {metrics.memoryCorrectionSuccess.value.toFixed(2)}%
            {metrics.memoryCorrectionSuccess.value < 90 && <span className="ml-2 bg-red-600 text-white px-2 py-1 rounded">Low</span>}
          </h3>
          <Sparklines data={metrics.memoryCorrectionSuccess.history} width={100} height={20}>
            <SparklinesLine color={metrics.memoryCorrectionSuccess.value < 90 ? 'red' : 'green'} />
          </Sparklines>
        </div>
      </div>
      <div className="mt-4">
        <button
          className="bg-blue-500 text-white px-4 py-2 rounded"
          onClick={() => setIsDebugOpen(!isDebugOpen)}
        >
          {isDebugOpen ? 'Hide' : 'Show'} Codon Debug Info
        </button>
        {isDebugOpen && (
          <div className="mt-2 p-4 bg-gray-200 rounded">
            <h4>Dominant Mutation: {metrics.topCodonDrift}</h4>
            <h4>Repair Attempts: {metrics.memoryRepairs}</h4>
          </div>
        )}
      </div>
    </div>
  );
};

export default AgentStressDashboard;

import React, { useState } from 'react';
import { v4 as uuidv4 } from 'uuid';

const ChatBot = ({ apiUrl = 'https://bioquantum-api.onrender.com', authToken }) => {
  const [message, setMessage] = useState('');
  const [responses, setResponses] = useState([]);

  const sendMessage = async () => {
    if (!message) return;
    
    try {
      const response = await fetch(`${apiUrl}/nugget/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          userId: 'chatbot_user',
          content: message,
          promptId: `prompt_${uuidv4()}`,
          context: { sessionId: `session_${uuidv4()}` }
        })
      });
      
      const data = await response.json();
      setResponses(prev => [...prev, { message, response: data }].slice(-50));
      setMessage('');
    } catch (error) {
      console.error('‚ùå ChatBot error:', error);
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-2xl font-bold mb-4">AI Trading ChatBot</h2>
      <div className="mb-4">
        <input
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Enter trading prompt"
          className="w-full p-2 border rounded"
        />
        <button 
          onClick={sendMessage}
          className="mt-2 bg-blue-500 text-white px-4 py-2 rounded"
        >
          Send
        </button>
      </div>
      <div>
        <h3 className="text-lg font-semibold mb-2">Responses</h3>
        <ul className="space-y-2">
          {responses.map((res, index) => (
            <li key={index} className="bg-gray-100 p-2 rounded">
              <div className="font-semibold">Prompt: {res.message}</div>
              <div className="text-gray-600">Response: {JSON.stringify(res.response)}</div>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default ChatBot;

const axios = require('axios');

const demoPromptPack = {
  "demo-session-001": {
    sessionId: "demo-session-001",
    sessionName: "Smart AAPL Momentum Strategy",
    description: "Well-structured momentum trading with proper risk management",
    nuggets: [
      {
        nuggetId: "nugget-001-001",
        sessionId: "demo-session-001",
        promptId: "prompt-001",
        userId: "Richard",
        content: "Monitor AAPL when RSI drops below 30 and volume exceeds 50M shares",
        type: "Condition",
        origin: "User",
        semanticIndex: ["AAPL", "RSI", "<30", "volume", ">50M", "oversold", "momentum"],
        temporalCluster: "2025-07-28T09:15:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" },
        outcome: {
          result: "Condition triggered - AAPL RSI hit 28.5 with 65M volume",
          timestamp: "2025-07-28T10:30:00Z",
          notes: "Clean oversold signal with high volume confirmation"
        }
      },
      {
        nuggetId: "nugget-001-002",
        sessionId: "demo-session-001",
        promptId: "prompt-002",
        userId: "Richard",
        content: "Buy AAPL with 2% position size, stop loss at -3%, target +8%",
        type: "Action",
        origin: "Strategy",
        semanticIndex: ["AAPL", "buy", "2%", "position", "stop", "-3%", "target", "+8%"],
        temporalCluster: "2025-07-28T10:35:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" },
        outcome: {
          result: "Profit +6.2% - Target nearly reached",
          timestamp: "2025-07-28T14:20:00Z",
          notes: "Position closed manually near target, excellent execution"
        }
      },
      {
        nuggetId: "nugget-001-003",
        sessionId: "demo-session-001",
        promptId: "prompt-003",
        userId: "Richard",
        content: "Log successful AAPL momentum pattern for future reference",
        type: "Memory",
        origin: "System",
        semanticIndex: ["AAPL", "momentum", "success", "pattern", "RSI30", "volume50M"],
        temporalCluster: "2025-07-28T14:25:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" }
      }
    ]
  },
  "demo-session-002": {
    sessionId: "demo-session-002",
    sessionName: "Conflicting TSLA Signals",
    description: "Session with contradictory conditions - shows anomaly detection",
    nuggets: [
      {
        nuggetId: "nugget-002-001",
        sessionId: "demo-session-002",
        promptId: "prompt-004",
        userId: "Richard",
        content: "Buy TSLA when price breaks above $300 resistance",
        type: "Condition",
        origin: "User",
        semanticIndex: ["TSLA", "price", ">300", "resistance", "breakout", "bullish"],
        temporalCluster: "2025-07-28T11:00:00Z",
        contextAttribution: { userId: "Richard", agentId: "ChatGPT" }
      },
      {
        nuggetId: "nugget-002-002",
        sessionId: "demo-session-002",
        promptId: "prompt-005",
        userId: "Richard",
        content: "Sell TSLA if price drops below $295 support level",
        type: "Condition",
        origin: "User",
        semanticIndex: ["TSLA", "price", "<295", "support", "breakdown", "bearish"],
        temporalCluster: "2025-07-28T11:05:00Z",
        contextAttribution: { userId: "Richard", agentId: "ChatGPT" }
      },
      {
        nuggetId: "nugget-002-003",
        sessionId: "demo-session-002",
        promptId: "prompt-006",
        userId: "Richard",
        content: "TSLA showing mixed signals - recommend 1% position size only",
        type: "Risk Assessment",
        origin: "Agent",
        semanticIndex: ["TSLA", "mixed", "signals", "1%", "position", "caution"],
        temporalCluster: "2025-07-28T11:10:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" }
      }
    ]
  },
  "demo-session-003": {
    sessionId: "demo-session-003",
    sessionName: "Flawed SPY Day Trading",
    description: "Multiple red flags - over-leveraged, no stops, emotion-driven",
    nuggets: [
      {
        nuggetId: "nugget-003-001",
        sessionId: "demo-session-003",
        promptId: "prompt-007",
        userId: "Richard",
        content: "All-in SPY calls because market always goes up",
        type: "Action",
        origin: "User",
        semanticIndex: ["SPY", "calls", "all-in", "market", "up", "gambling"],
        temporalCluster: "2025-07-28T13:30:00Z",
        contextAttribution: { userId: "Richard", agentId: "Manus" },
        outcome: {
          result: "Loss -12.4% - Market dropped on Fed news",
          timestamp: "2025-07-28T15:45:00Z",
          notes: "No risk management, emotional decision"
        }
      },
      {
        nuggetId: "nugget-003-002",
        sessionId: "demo-session-003",
        promptId: "prompt-008",
        userId: "Richard",
        content: "Double down on SPY - buy more calls to average down",
        type: "Action",
        origin: "User",
        semanticIndex: ["SPY", "calls", "double", "average", "down", "revenge"],
        temporalCluster: "2025-07-28T15:50:00Z",
        contextAttribution: { userId: "Richard", agentId: "Manus" },
        outcome: {
          result: "Loss -23.8% - Continued market decline",
          timestamp: "2025-07-28T16:30:00Z",
          notes: "Revenge trading - doubled down on losing position"
        }
      }
    ]
  },
  "demo-session-004": {
    sessionId: "demo-session-004",
    sessionName: "NVDA Learning & Recovery",
    description: "Shows learning from mistakes and course correction",
    nuggets: [
      {
        nuggetId: "nugget-004-001",
        sessionId: "demo-session-004",
        promptId: "prompt-009",
        userId: "Richard",
        content: "Buy NVDA on earnings beat without checking technicals",
        type: "Action",
        origin: "User",
        semanticIndex: ["NVDA", "earnings", "buy", "no-technicals", "fundamental"],
        temporalCluster: "2025-07-28T16:45:00Z",
        contextAttribution: { userId: "Richard", agentId: "Grok" },
        outcome: {
          result: "Loss -4.2% - Stock sold off despite good earnings",
          timestamp: "2025-07-28T17:30:00Z",
          notes: "Learned: Always check technical levels even on good news"
        }
      },
      {
        nuggetId: "nugget-004-002",
        sessionId: "demo-session-004",
        promptId: "prompt-010",
        userId: "Richard",
        content: "Wait for NVDA pullback to 50-day MA before re-entry",
        type: "Condition",
        origin: "Learning",
        semanticIndex: ["NVDA", "pullback", "50MA", "re-entry", "technical", "patience"],
        temporalCluster: "2025-07-28T17:35:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" }
      },
      {
        nuggetId: "nugget-004-003",
        sessionId: "demo-session-004",
        promptId: "prompt-011",
        userId: "Richard",
        content: "NVDA touched 50MA support - buy with 1.5% position and tight stop",
        type: "Action",
        origin: "Strategy",
        semanticIndex: ["NVDA", "50MA", "support", "buy", "1.5%", "tight-stop"],
        temporalCluster: "2025-07-29T10:15:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" },
        outcome: {
          result: "Profit +5.7% - Clean bounce from support level",
          timestamp: "2025-07-29T14:20:00Z",
          notes: "Patience and technical analysis paid off"
        }
      }
    ]
  },
  "demo-session-005": {
    sessionId: "demo-session-005",
    sessionName: "Multi-Asset Correlation Play",
    description: "Advanced strategy tracking correlations between assets",
    nuggets: [
      {
        nuggetId: "nugget-005-001",
        sessionId: "demo-session-005",
        promptId: "prompt-012",
        userId: "Richard",
        content: "Monitor USD/JPY above 150 for tech sector weakness signal",
        type: "Condition",
        origin: "Strategy",
        semanticIndex: ["USD/JPY", ">150", "tech", "weakness", "correlation", "currency"],
        temporalCluster: "2025-07-28T08:30:00Z",
        contextAttribution: { userId: "Richard", agentId: "Claude" }
      }
    ]
  }
};

async function loadDemoPrompts() {
  const baseUrl = 'http://localhost:10000';
  const jwtToken = require('jsonwebtoken').sign({ userId: 'richard' }, process.env.JWT_SECRET || 'dummy_jwt_secret_123', { expiresIn: '1h' });

  for (const session of Object.values(demoPromptPack)) {
    console.log(`Loading session: ${session.sessionName}`);
    for (const nugget of session.nuggets) {
      try {
        const response = await axios.post(`${baseUrl}/nugget/create`, nugget, {
          headers: {
            'Authorization': `Bearer ${jwtToken}`,
            'Content-Type': 'application/json'
          }
        });
        console.log(`Loaded nugget ${nugget.nuggetId}: ${response.data.status}`);
      } catch (err) {
        console.error(`Error loading nugget ${nugget.nuggetId}:`, err.response?.data || err.message);
      }
    }
  }
}

loadDemoPrompts();

@echo off
setlocal EnableDelayedExpansion

:: Config
set REPO_DIR=C:\CAI-Sync-System\bio-quantum-trading-platform-clean
set BRANCH=deploy-clean
set MANUS_DIR=C:\CAI-Sync-System\Manus files
set ZIP_FILE=bio-quantum-source-code.zip
set GROK_FILES_DIR=C:\CAI-Sync-System\Grk Files\Grok Files\Grok Files
set GITHUB_URL=https://github.com/rica/bio-quantum-trading-platform-clean.git
set LOG_FILE=%REPO_DIR%\sync.log

:: Start logging
echo [%date% %time%] Starting sync > "%LOG_FILE%"

:: Check repo
cd /d "%REPO_DIR%" || (echo [ERROR] Invalid repo path >> "%LOG_FILE%" & exit /b 1)
dir /a >> "%LOG_FILE%"

:: Delete mistaken repo
echo Deleting mistaken repo >> "%LOG_FILE%"
rd /s /q "C:\Users\richa\Documents\GitHub\bio-quantum-deployment" 2>> "%LOG_FILE%"

:: Initialize Git
if not exist .git (
    echo Initializing Git >> "%LOG_FILE%"
    git init >> "%LOG_FILE%" 2>&1
    git checkout -b main >> "%LOG_FILE%" 2>&1
    git add . >> "%LOG_FILE%" 2>&1
    git commit -m "Initial commit" >> "%LOG_FILE%" 2

//  Incident Response Playbook
//
This playbook defines incident response procedures for the Bio-Quantum Trading Platform security incidents.
//
//
**Indicators:**
- JWT authentication completely compromised
- Multiple simultaneous codon mutations detected
- Memory corruption across sessions
- Replay attacks exceeding 50 per minute

**Auto-Mitigation:**
- Ban IP immediately
- Invalidate all tokens for affected sessions
- Quarantine affected memory strands
- Enable emergency read-only mode

**Response Time:** < 5 minutes
//
**Indicators:**
- JWT validation failures > 20 per minute
- Codon mutation rate > 30%
- Session tampering detected
- Federated threat sync disruption

**Auto-Mitigation:**
- Rate limit affected IPs
- Increase validation thresholds
- Alert security team
- Begin evidence collection

**Response Time:** < 15 minutes
//
**Indicators:**
- Rate limiting violations
- Minor codon drift patterns
- WebSocket connection anomalies
- Trust score degradation

**Auto-Mitigation:**
- Log detailed metrics
- Adjust rate limits
- Monitor closely

**Response Time:** < 30 minutes
//
**Indicators:**
- Occasional validation failures
- Normal codon variation
- Standard connection issues

**Auto-Mitigation:**
- Standard logging
- Continue monitoring

**Response Time:** < 1 hour
//

1. **Automated Detection** ‚Üí SecurityNetworkWatchdog
2. **Threat Assessment** ‚Üí FederatedThreatSyncProtocol
3. **Evidence Collection** ‚Üí BioQuantumEvidenceCollector
4. **Response Execution** ‚Üí Automated + Manual Review
5. **Post-Incident Analysis** ‚Üí Update threat signatures
//

**Security Team:** security@bio-quantum.ai
**Emergency Line:** +1-XXX-XXX-XXXX
**Incident Commander:** Richard Anderson

{
  "format_version": "1.0",
  "last_updated": "2025-07-31T10:30:00Z",
  "fingerprints": [
    {
      "id": "fingerprint_001",
      "agent_source": "claude",
      "timestamp": "2025-07-31T10:30:00Z",
      "codon_signature": {
        "pattern": [
          { "position": 0, "codon": "ATCG", "weight": 0.8 },
          { "position": 1, "codon": "GCTA", "weight": 0.6 },
          { "position": 2, "codon": "CGAT", "weight": 0.9 }
        ],
        "classification": "jwt_anomaly",
        "severity": "high",
        "confidence": 0.85
      },
      "vector_data": {
        "type": "authentication_failure",
        "endpoints": ["/nugget/create", "/nugget/validate"],
        "ips": ["192.168.1.100", "10.0.0.50"],
        "signatures": ["invalid_token_format", "expired_timestamp"]
      },
      "metadata": {
        "detection_method": "pattern_analysis",
        "false_positive_rate": 0.05,
        "correlation_id": "incident_001"
      }
    },
    {
      "id": "fingerprint_002",
      "agent_source": "grok",
      "timestamp": "2025-07-31T10:25:00Z",
      "codon_signature": {
        "pattern": [
          { "position": 0, "codon": "TGCA", "weight": 0.7 },
          { "position": 1, "codon": "AGTC", "weight": 0.8 }
        ],
        "classification": "rate_limit_exceeded",
        "severity": "medium",
        "confidence": 0.75
      },
      "vector_data": {
        "type": "ddos_pattern",
        "endpoints": ["/nugget/create"],
        "ips": ["203.0.113.1"],
        "signatures": ["burst_requests"]
      },
      "metadata": {
        "detection_method": "threshold_analysis",
        "false_positive_rate": 0.1
      }
    }
  ]
}

[
  {
    "id": "threat_001",
    "timestamp": "2025-07-31T10:30:00Z",
    "source_agent": "claude",
    "threat_type": "jwt_anomaly",
    "severity": "high",
    "confidence": 0.85,
    "vector_hash": "a1b2c3d4e5f6",
    "session_source": "demo-session-001",
    "risk_level": "critical",
    "auto_mitigated": true,
    "mitigation_actions": [
      "invalidated_session",
      "blocked_ip",
      "increased_monitoring"
    ],
    "fingerprint_id": "fingerprint_001",
    "synced_at": "2025-07-31T10:31:00Z"
  },
  {
    "id": "threat_002",
    "timestamp": "2025-07-31T10:25:00Z",
    "source_agent": "grok",
    "threat_type": "rate_limit_exceeded",
    "severity": "medium",
    "confidence": 0.75,
    "vector_hash": "b2c3d4e5f6a1",
    "session_source": "demo-session-002",
    "risk_level": "moderate",
    "auto_mitigated": true,
    "mitigation_actions": [
      "applied_rate_limit",
      "flagged_ip"
    ],
    "fingerprint_id": "fingerprint_002",
    "synced_at": "2025-07-31T10:26:00Z"
  },
  {
    "id": "threat_003",
    "timestamp": "2025-07-31T10:20:00Z",
    "source_agent": "chatgpt",
    "threat_type": "codon_mutation",
    "severity": "low",
    "confidence": 0.6,
    "vector_hash": "c3d4e5f6a1b2",
    "session_source": "demo-session-003",
    "risk_level": "low",
    "auto_mitigated": false,
    "mitigation_actions": [
      "logged_event"
    ],
    "fingerprint_id": "fingerprint_003",
    "synced_at": "2025-07-31T10:21:00Z"
  }
]

[
  {
    "id": "alert_001",
    "timestamp": "2025-07-31T10:30:00Z",
    "ip": "192.168.1.100",
    "sessionId": "demo-session-001",
    "threatLevel": "critical",
    "eventType": "invalid_jwt",
    "details": "JWT signature verification failed",
    "auto_mitigated": true,
    "mitigation_actions": ["session_invalidated", "ip_blocked"]
  },
  {
    "id": "alert_002",
    "timestamp": "2025-07-31T10:25:00Z",
    "ip": "203.0.113.1",
    "sessionId": "demo-session-002",
    "threatLevel": "high",
    "eventType": "session_spamming",
    "details": "Request rate exceeded 100 per minute",
    "auto_mitigated": true,
    "mitigation_actions": ["rate_limit_applied"]
  },
  {
    "id": "alert_003",
    "timestamp": "2025-07-31T10:20:00Z",
    "ip": "10.0.0.50",
    "sessionId": "demo-session-003",
    "threatLevel": "medium",
    "eventType": "codon_drift",
    "details": "Unusual codon mutation pattern detected",
    "auto_mitigated": false,
    "mitigation_actions": ["increased_monitoring"]
  }
]

//  KM Nugget Validation Artifact Index
//
This document indexes all validation artifacts and components for the Bio-Quantum Trading Platform's Knowledge Management (KM) Nugget system.
//
//
**Location:** `backend/bio_quantum_api/src/KMNuggetValidationEngine.js`
**Purpose:** Primary validation engine with ML-based confidence scoring
**Features:**
- Confidence threshold analysis (default: 0.7)
- Anomaly detection using cosine similarity
- Freshness weight computation
- Historical accuracy correlation
- Volatility correlation analysis
//
**Location:** `backend/bio_quantum_api/validation/CrossSessionValidator.js`
**Purpose:** Prevent replay attacks and ensure session integrity
**Features:**
- Request hash generation and tracking
- Session expiration management (default: 1 hour)
- Replay attack detection
- Cross-session validation
//
**Location:** `backend/bio_quantum_api/src/CodonGenerator.js`
**Purpose:** Generate DNA-inspired validation sequences
**Features:**
- Cryptographic seed-based generation
- Customizable codon alphabet (A, C, G, T)
- DEG sequence integration
- Validator integration hooks
//
//
**Method:** POST
**Purpose:** Single nugget validation
**Request Body:**
{
  "nugget": {
    "nuggetId": "string",
    "content": "string",
    "timestamp": "ISO8601",
    "sourceCredibility": "float",
    "historicalAccuracy": "float",
    "volatilityCorrelation": "float"
  },
  "comparisonSet": [...]
}
//
**Method:** POST
**Purpose:** Multiple nugget validation
**Request Body:**
{
  "nuggets": [...],
  "comparisonSet": [...]
}
//
//
- Real-time validation monitoring
- Threat pattern detection
- Automated response triggers
- Evidence collection coordination
//
- Cross-agent validation sharing
- Trust score management
- Threat signature distribution
- Codon fingerprint synchronization
//
//
1. **Source Weight** (25%): Credibility of information source
2. **Freshness Weight** (25%): Time-based relevance decay
3. **Historical Weight** (25%): Past accuracy performance
4. **Volatility Weight** (25%): Market condition correlation
//
- **Default Threshold:** 0.3
- **Method:** Cosine similarity distance
- **Comparison:** Against historical nugget corpus
- **Action:** Flag for manual review if exceeded
//
//
CONFIDENCE_THRESHOLD=0.7
ANOMALY_THRESHOLD=0.3
SESSION_TIMEOUT_MS=3600000
VALIDATION_LOG_LEVEL=INFO
//
{
  "validation": {
    "confidenceThreshold": 0.7,
    "anomalyThreshold": 0.3,
    "enableCrossSession": true,
    "enableCodonGeneration": true,
    "maxSessionAge": 3600000
  }
}
//
//
- **Location:** `backend/bio_quantum_api/src/loadDemoPrompts.js`
- **Sessions:** 5 demo trading sessions
- **Scenarios:** Success, conflict, failure, learning, correlation
- **Coverage:** All validation edge cases
//
1. **High Confidence Nuggets** - Should pass validation
2. **Low Confidence Nuggets** - Should fail validation
3. **Anomalous Content** - Should trigger anomaly detection
4. **Replay Attacks** - Should be blocked by CrossSessionValidator
5. **Expired Sessions** - Should be invalidated
//
//
- Monitor validation accuracy metrics
- Update confidence thresholds based on performance
- Refresh demo data sets
- Review and update threat signatures
//
- Disable validation temporarily: Set `CONFIDENCE_THRESHOLD=0`
- Emergency session cleanup: Clear session store
- Reset codon generator: Update seed value
- Validation bypass: Use emergency admin tokens
//
//
- `StrategyMemoryMap.jsx` - Displays validation results
- `SecurityDashboard.jsx` - Shows validation alerts
- `AgentStressDashboard.jsx` - Validation performance metrics
//
- Redis caching for validation results
- WebSocket broadcasting for real-time updates
- JWT authentication for endpoint security
- File system logging for audit trails
//
//
- Validation results cached in Redis (1 hour TTL)
- Confidence scores memoized for identical content
- Comparison sets cached by hash signature
//
- Horizontal scaling via Redis clustering
- Load balancing across validation instances
- Asynchronous validation for non-critical paths
- Batch processing for bulk operations

---

**Last Updated:** 2025-07-31T10:30:00Z
**Version:** 2.1.0
**Maintainer:** Richard Anderson <richard@bio-quantum.ai>

import React from 'react';

const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  size = 'medium', 
  disabled = false,
  className = '',
  ...props 
}) => {
  const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500',
    success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
    warning: 'bg-yellow-600 text-white hover:bg-yellow-700 focus:ring-yellow-500',
    outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 focus:ring-blue-500'
  };
  
  const sizes = {
    small: 'px-3 py-2 text-sm',
    medium: 'px-4 py-2 text-base',
    large: 'px-6 py-3 text-lg'
  };
  
  const disabledClasses = disabled ? 'opacity-50 cursor-not-allowed' : '';
  
  const buttonClasses = `${baseClasses} ${variants[variant]} ${sizes[size]} ${disabledClasses} ${className}`;
  
  return (
    <button
      className={buttonClasses}
      onClick={onClick}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
};

export default Button;

import React from 'react';

const Input = ({ 
  type = 'text',
  placeholder,
  value,
  onChange,
  disabled = false,
  error,
  label,
  className = '',
  ...props 
}) => {
  const baseClasses = 'w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500';
  const errorClasses = error ? 'border-red-500 focus:ring-red-500' : 'border-gray-300';
  const disabledClasses = disabled ? 'bg-gray-100 cursor-not-allowed' : 'bg-white';
  
  const inputClasses = `${baseClasses} ${errorClasses} ${disabledClasses} ${className}`;
  
  return (
    <div className="space-y-1">
      {label && (
        <label className="block text-sm font-medium text-gray-700">
          {label}
        </label>
      )}
      <input
        type={type}
        placeholder={placeholder}
        value={value}
        onChange={onChange}
        disabled={disabled}
        className={inputClasses}
        {...props}
      />
      {error && (
        <p className="text-sm text-red-600">{error}</p>
      )}
    </div>
  );
};

export default Input;

import { useState, useEffect, useRef } from 'react';

const useWebSocket = (url, authToken, options = {}) => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const wsRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const reconnectAttemptsRef = useRef(0);
  
  const {
    maxReconnectAttempts = 5,
    reconnectInterval = 3000,
    onMessage,
    onConnect,
    onDisconnect,
    onError
  } = options;

  const connect = () => {
    if (!authToken) {
      setError('Authentication token required');
      return;
    }

    try {
      setConnectionStatus('connecting');
      const wsUrl = `${url}?token=${authToken}`;
      wsRef.current = new WebSocket(wsUrl);
      
      wsRef.current.onopen = () => {
        console.log('üîå WebSocket connected');
        setIsConnected(true);
        setConnectionStatus('connected');
        setError(null);
        reconnectAttemptsRef.current = 0;
        onConnect?.();
      };
      
      wsRef.current.onmessage = (event) => {
        try {
          const parsedData = JSON.parse(event.data);
          setData(parsedData);
          onMessage?.(parsedData);
        } catch (err) {
          console.error('‚ùå WebSocket message parsing error:', err);
          setError('Failed to parse message');
        }
      };
      
      wsRef.current.onclose = (event) => {
        console.log('üîå WebSocket disconnected:', event.code, event.reason);
        setIsConnected(false);
        setConnectionStatus('disconnected');
        onDisconnect?.(event);
        
        // Attempt reconnection if not a clean close
        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {
          setConnectionStatus('reconnecting');
          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttemptsRef.current++;
            console.log(`üîÑ Reconnection attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts}`);
            connect();
          }, reconnectInterval);
        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {
          setError('Max reconnection attempts reached');
          setConnectionStatus('failed');
        }
      };
      
      wsRef.current.onerror = (event) => {
        console.error('‚ùå WebSocket error:', event);
        setError('WebSocket connection error');
        setConnectionStatus('error');
        onError?.(event);
      };
      
    } catch (err) {
      console.error('‚ùå WebSocket connection failed:', err);
      setError('Failed to establish connection');
      setConnectionStatus('failed');
    }
  };

  const disconnect = () => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'Client disconnect');
    }
    
    setIsConnected(false);
    setConnectionStatus('disconnected');
  };

  const sendMessage = (message) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      try {
        const messageString = typeof message === 'string' ? message : JSON.stringify(message);
        wsRef.current.send(messageString);
        return true;
      } catch (err) {
        console.error('‚ùå Failed to send message:', err);
        setError('Failed to send message');
        return false;
      }
    } else {
      console.warn('‚ö†Ô∏è WebSocket not connected, cannot send message');
      setError('WebSocket not connected');
      return false;
    }
  };

  useEffect(() => {
    if (url && authToken) {
      connect();
    }
    
    return () => {
      disconnect();
    };
  }, [url, authToken]);

  return {
    data,
    error,
    isConnected,
    connectionStatus,
    sendMessage,
    disconnect,
    reconnect: connect
  };
};

export default useWebSocket;
